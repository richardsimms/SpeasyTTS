import { promises as fs } from 'fs';
import path from 'path';
import { execSync } from 'child_process';

interface AudioValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  metadata: {
    format?: string;
    bitrate?: number;
    sampleRate?: number;
    duration?: number;
    fileSize?: number;
    hasId3Tags?: boolean;
  };
}

interface AudioRequirements {
  maxFileSizeBytes: number;      // e.g., 200MB = 200 * 1024 * 1024
  minBitrate: number;           // e.g., 64 kbps
  maxBitrate: number;           // e.g., 320 kbps
  allowedSampleRates: number[]; // e.g., [44100, 48000]
  allowedFormats: string[];     // e.g., ['mp3', 'm4a']
}

const defaultRequirements: AudioRequirements = {
  maxFileSizeBytes: 200 * 1024 * 1024, // 200MB max
  minBitrate: 64,                      // 64 kbps min
  maxBitrate: 320,                     // 320 kbps max
  allowedSampleRates: [44100, 48000],  // Standard sample rates
  allowedFormats: ['mp3', 'm4a']       // Allowed formats
};

export async function validatePodcastAudio(
  filePath: string, 
  requirements: AudioRequirements = defaultRequirements
): Promise<AudioValidationResult> {
  const result: AudioValidationResult = {
    isValid: true,
    errors: [],
    warnings: [],
    metadata: {}
  };

  try {
    // 1. Check if file exists
    const stats = await fs.stat(filePath);
    result.metadata.fileSize = stats.size;

    // 2. Check file size
    if (stats.size > requirements.maxFileSizeBytes) {
      result.errors.push(`File size ${(stats.size / 1024 / 1024).toFixed(2)}MB exceeds maximum allowed size of ${(requirements.maxFileSizeBytes / 1024 / 1024)}MB`);
    }

    // 3. Check file extension
    const fileExt = path.extname(filePath).toLowerCase().replace('.', '');
    if (!requirements.allowedFormats.includes(fileExt)) {
      result.errors.push(`File format ${fileExt} is not supported. Supported formats: ${requirements.allowedFormats.join(', ')}`);
    }

    // 4. Use ffprobe to get detailed audio metadata
    try {
      const ffprobeOutput = execSync(`ffprobe -v quiet -print_format json -show_format -show_streams "${filePath}"`);
      const metadata = JSON.parse(ffprobeOutput.toString());

      const audioStream = metadata.streams.find((stream: any) => stream.codec_type === 'audio');
      if (!audioStream) {
        result.errors.push('No audio stream found in file');
      } else {
        // Get audio properties
        result.metadata.format = audioStream.codec_name;
        result.metadata.bitrate = parseInt(metadata.format.bit_rate) / 1000; // Convert to kbps
        result.metadata.sampleRate = parseInt(audioStream.sample_rate);
        result.metadata.duration = parseFloat(metadata.format.duration);

        // Validate bitrate
        if (result.metadata.bitrate < requirements.minBitrate) {
          result.errors.push(`Bitrate ${result.metadata.bitrate}kbps is below minimum ${requirements.minBitrate}kbps`);
        }
        if (result.metadata.bitrate > requirements.maxBitrate) {
          result.errors.push(`Bitrate ${result.metadata.bitrate}kbps exceeds maximum ${requirements.maxBitrate}kbps`);
        }

        // Validate sample rate
        if (!requirements.allowedSampleRates.includes(result.metadata.sampleRate)) {
          result.errors.push(`Sample rate ${result.metadata.sampleRate}Hz is not supported. Supported rates: ${requirements.allowedSampleRates.join(', ')}Hz`);
        }
      }
    } catch (error) {
      result.errors.push('Failed to read audio metadata. Ensure ffmpeg is installed and the file is not corrupted.');
    }

    // 5. Check for ID3 tags if MP3
    if (fileExt === 'mp3') {
      try {
        const id3Output = execSync(`ffprobe -v quiet -print_format json -show_format "${filePath}"`);
        const id3Data = JSON.parse(id3Output.toString());
        result.metadata.hasId3Tags = Object.keys(id3Data.format.tags || {}).length > 0;
        
        if (!result.metadata.hasId3Tags) {
          result.warnings.push('Missing ID3 tags. While not required, tags help with podcast metadata.');
        }
      } catch (error) {
        result.warnings.push('Could not check ID3 tags');
      }
    }

  } catch (error) {
    result.errors.push(`Failed to access file: ${error.message}`);
  }

  // Set overall validity
  result.isValid = result.errors.length === 0;

  return result;
}

// Example usage and helper functions
export async function validateAndFixAudio(filePath: string): Promise<string> {
  const validation = await validatePodcastAudio(filePath);
  
  if (validation.isValid) {
    return 'Audio file is valid for podcast use.';
  }

  let suggestedFixes = [];
  
  // Analyze issues and suggest fixes
  validation.errors.forEach(error => {
    if (error.includes('bitrate')) {
      suggestedFixes.push(`
        Fix bitrate issues with ffmpeg:
        ffmpeg -i "${filePath}" -codec:a libmp3lame -b:a 128k "fixed_${path.basename(filePath)}"
      `);
    }
    
    if (error.includes('sample rate')) {
      suggestedFixes.push(`
        Fix sample rate with ffmpeg:
        ffmpeg -i "${filePath}" -codec:a libmp3lame -ar 44100 "fixed_${path.basename(filePath)}"
      `);
    }
    
    if (error.includes('file format')) {
      suggestedFixes.push(`
        Convert to MP3 with ffmpeg:
        ffmpeg -i "${filePath}" -codec:a libmp3lame -b:a 128k "${path.basename(filePath, path.extname(filePath))}.mp3"
      `);
    }
  });

  // Add ID3 tag suggestion if missing
  if (validation.warnings.some(w => w.includes('ID3'))) {
    suggestedFixes.push(`
      Add basic ID3 tags with ffmpeg:
      ffmpeg -i "${filePath}" -codec:a copy -metadata title="Episode Title" -metadata artist="Podcast Name" "tagged_${path.basename(filePath)}"
    `);
  }

  return `
Audio file validation failed with the following issues:

Errors:
${validation.errors.map(e => '- ' + e).join('\n')}

Warnings:
${validation.warnings.map(w => '- ' + w).join('\n')}

File metadata:
${Object.entries(validation.metadata)
  .map(([key, value]) => `- ${key}: ${value}`)
  .join('\n')}

Suggested fixes:
${suggestedFixes.join('\n')}

Note: These commands require ffmpeg to be installed on your system.
`;
}